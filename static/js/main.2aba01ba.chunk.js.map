{"version":3,"sources":["Movie.js","App.js","serviceWorker.js","index.js"],"names":["Movie","title","image","genres","synopsis","rating","year","className","src","alt","map","genre","index","slice","App","state","isLoading","movies","_getMovies","a","async","axios","get","data","console","log","setState","this","movie","key","id","title_english","medium_cover_image","_renderMovie","Component","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"sUAqFeA,MA7Bf,YAAkE,IAAjDC,EAAgD,EAAhDA,MAAOC,EAAyC,EAAzCA,MAAOC,EAAkC,EAAlCA,OAAQC,EAA0B,EAA1BA,SAAUC,EAAgB,EAAhBA,OAAQC,EAAQ,EAARA,KACvD,OACE,yBAAKC,UAAU,SACb,yBAAKA,UAAU,aACb,yBAAKC,IAAKN,EAAOO,IAAKR,EAAOM,UAAU,iBADzC,KAGA,yBAAKA,UAAU,cACb,wBAAIA,UAAU,eAAeN,GAC7B,wBAAIM,UAAU,cACXD,EADH,mBACeD,GAEf,uBAAGE,UAAU,gBACVJ,EAAOO,KAAI,SAACC,EAAOC,GAAR,OACV,0BAAML,UAAU,gBAAgBI,OAGpC,uBAAGJ,UAAU,kBAAkBH,EAASS,MAAM,EAAG,KAAjD,U,iBC0DOC,E,2MAvGbC,MAAQ,CACNC,WAAW,EACXC,OAAQ,I,EA6DVC,WAAa,4BAAAC,EAAAC,OAAA,kEAAAD,EAAA,MAKDE,IAAMC,IACd,0DANS,gBAGCL,EAHD,EAETM,KACEA,KAAQN,OAMZO,QAAQC,IAAIR,GAEZ,EAAKS,SAAS,CAAET,SAAQD,WAAW,IAXxB,sC,oFAzDXQ,QAAQC,IAAI,gB,0CAuBZE,KAAKT,e,+BA0DG,IAAD,EACuBS,KAAKZ,MAA3BC,EADD,EACCA,UAAWC,EADZ,EACYA,OAGnB,OADAO,QAAQC,IAAI,cAEV,yBAAKlB,UAAU,OACZS,EACC,yBAAKT,UAAU,UAAf,WAEA,yBAAKA,UAAU,UAtHJ,SAAAU,GACnB,OAAOA,EAAOP,KAAI,SAAAkB,GAAK,OACrB,kBAAC,EAAD,CACEC,IAAKD,EAAME,GACX7B,MAAO2B,EAAMG,cACb7B,MAAO0B,EAAMI,mBACb7B,OAAQyB,EAAMzB,OACdC,SAAUwB,EAAMxB,SAChBC,OAAQuB,EAAMvB,OACdC,KAAMsB,EAAMtB,UA6GiB2B,CAAahB,S,GAjG9BiB,aCdEC,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCZNC,IAASC,OAAO,kBAAC,EAAD,MAASC,SAASC,eAAe,SD6H3C,kBAAmBC,WACrBA,UAAUC,cAAcC,MAAMC,MAAK,SAAAC,GACjCA,EAAaC,kB","file":"static/js/main.2aba01ba.chunk.js","sourcesContent":["import React from \"react\";\r\nimport PropsTypes from \"prop-types\";\r\nimport \"./Movie.css\";\r\n\r\n/*\r\nclass Movie extends Component {\r\n\r\n    static propsTypes = {\r\n        title : PropsTypes.string.isRequired,\r\n        image:PropsTypes.string.isRequired\r\n    }\r\n\r\n    render() {\r\n        console.log(this.props);\r\n        return (\r\n            <div>\r\n               <MoviePoster movieImg = {this.props.image}/>\r\n                <h1>{this.props.title}</h1> \r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\n클래스 컴포넌트를 만들어서 사용해도 작동은 정상적으로 가능하지만\r\nMoivePoster은 componentWillMount, update state 등등이 필요가 없다.\r\n오직 한개의 props만 있으면 된다.  \r\n\r\n\r\nclass MoviePoster extends Component{\r\n\r\n    static propsTypes = {\r\n        movieImg:PropsTypes.string.isRequired\r\n    }\r\n\r\n    render(){\r\n        return (\r\n            <img src = {this.props.movieImg} alt = 'Movie Poster'/>\r\n        );\r\n    }\r\n}\r\n\r\n <div className=\"Movie_Colums\">\r\n        <MoviePoster movieImg={image} alt={title} />\r\n      </div>\r\n      <div className=\"Movie_Colums\">\r\n        <h1>{title}</h1>\r\n        <div className=\"Movie_Genres\">\r\n          {genres.map((genre, index) => (\r\n            <MovieGenres genre={genre} key={index} />\r\n          ))}\r\n        </div>\r\n        <div>Rating : {rating}</div>\r\n        <p className=\"Movie_Synopsis\">{synopsis}</p>\r\n      </div>\r\n      <h1>{title}</h1>\r\n*/\r\nfunction Movie({ title, image, genres, synopsis, rating, year }) {\r\n  return (\r\n    <div className=\"Movie\">\r\n      <div className=\"Movie_img\">\r\n        <img src={image} alt={title} className=\"Movie_Poster\" />;\r\n      </div>\r\n      <div className=\"Movie_data\">\r\n        <h3 className=\"Movie_title\">{title}</h3>\r\n        <h5 className=\"Movie_year\">\r\n          {year} 평점 : {rating}\r\n        </h5>\r\n        <p className=\"Movie_genres\">\r\n          {genres.map((genre, index) => (\r\n            <span className=\"Movie_Genres\">{genre}</span>\r\n          ))}\r\n        </p>\r\n        <p className=\"Movie_synopsis\">{synopsis.slice(0, 180)}...</p>\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n\r\nMovie.propTypes = {\r\n  title: PropsTypes.string,\r\n  image: PropsTypes.string,\r\n  genres: PropsTypes.array,\r\n  synopsis: PropsTypes.string\r\n};\r\n\r\nexport default Movie;\r\n","import React, { Component } from \"react\";\nimport \"./App.css\";\nimport Movie from \"./Movie\";\nimport axios from \"axios\";\n\nconst _renderMovie = movies => {\n  return movies.map(movie => (\n    <Movie\n      key={movie.id}\n      title={movie.title_english}\n      image={movie.medium_cover_image}\n      genres={movie.genres}\n      synopsis={movie.synopsis}\n      rating={movie.rating}\n      year={movie.year}\n    />\n  ));\n};\n\n/*\n  willMoint() 는 렌더링이 완료되기 전이기 때문에 여기서 로딩 화면을 띄우고\n  didMount()는 렌더링이 완료된 것을 나타내기 때문에 여기서 로딩창을 지우면 된다!\n\n  setTimeout()은 몇초동안 기다리는 함수\n*/\n\nclass App extends Component {\n  state = {\n    isLoading: true,\n    movies: []\n  };\n\n  componentWillMount() {\n    console.log(\"will mount\");\n  }\n\n  /*\n    fetch를 쓰는게 AJAX를 쓰려고 하는건데 그 요소로는\n    json, xml 등등이 있고 이걸 쉽게 가져오려고 저걸 씀\n\n    이걸 쓰는 이유는 뭔갈 불러올때 페이지를 새로고침 등등 하기 싫어서 사용한다.\n\n    또 AJAX는 비동기화 작업이다. 2개의 API를 동시에 사용한다고 했을 때\n    동기식은 한개가 끝나야 나머지가 작업을 시작하는데 이는 한쪽이 속도가 느릴경우 문제가 있다.\n\n    AJAX의 promises는 하나의 작업이 끝나든 만들 두번째 작업을 수행한다.\n    즉 다른 작업과 전혀 관련없이 자신의 작업을 한다.\n\n    promises의 또다른 기능은 시나리오를 잡는 방법을 만들어준다.\n    즉 시나리오가 있고 이를 관리할 수 있다.\n\n    then은 fetch를 하고 추가로 작업할 것으로 1개의 오브젝트를 사용할 수 있다. 이는 response이고\n    catch는 에러가 나면 이것을 수행해라! 라는 것이다\n  */\n\n  componentDidMount() {\n    this._getMovies();\n  }\n  /*\n    async 는 위에서 말한 비동시화 방식으로 \n    다른 작업과 동시에 작동되는 것을 말하며\n\n    await는 뒤에있는 this._callApi() 기능이 끝나는 것을 기다리고,\n    그 값을 앞에있는 moives에 넣는다 \n\n    그러므로 this.setState({})는 this._callApi() 기능이 끝나기 전까지 실행되지 않는다\n  \n    또 this.setState() 안에 있는 movies는 모던자바스크립트 방식으로\n    movies : movies를 줄여서 적었다 보면된다\n    \n  바로 아래 getMoives 함수는 fecth를 사용할떄 쓰는 함수이다\n\n  _getMovies = async () => {\n    const movies = await this._callApi();\n    console.log(movies);\n    this.setState({\n      movies\n    });\n  };\n  */\n\n  /*\n  fetch를 사용하려고 했지만 axios를 사용하기로 하였다.\n  이것은 fetch 위에 단에서 움직이는 것이라고 생각하면 되고 먼저 yarn add axios로 설치한다\n  하지만 axios는 속도가 느리기때문에 앞에 await를 사용하여 먼저 axios가 완료되기까지 기다리도록 한다\n  \n  아래처럼 {data: {data:{movies}}}를 하지 않으면 movies를 사용할 때 \n  data.data.movies 이렇게 사용해야하기 떄문에 간단하게 하려고 위와같이 작업을 해준다\n  */\n\n  _getMovies = async () => {\n    const {\n      data: {\n        data: { movies }\n      }\n    } = await axios.get(\n      \"https://yts.lt/api/v2/list_movies.json?sort_by=rating\"\n    );\n\n    console.log(movies);\n\n    this.setState({ movies, isLoading: false });\n  };\n  /*\n  이것은 fetch를 사용할때의 함수  \n\n  _callApi = () => {\n    return fetch(\"https://yts.lt/api/v2/list_movies.json?sort_by=rating\")\n      .then(response => response.json())\n      .then(json => json.data.movies)\n      .catch(err => console.log(err));\n  };\n\n  */\n  render() {\n    const { isLoading, movies } = this.state;\n\n    console.log(\"render now\");\n    return (\n      <div className=\"App\">\n        {isLoading ? (\n          <div className=\"loader\">Loading</div>\n        ) : (\n          <div className=\"movies\">{_renderMovie(movies)}</div>\n        )}\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}